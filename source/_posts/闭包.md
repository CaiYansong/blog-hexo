---
title: 闭包
---

<a name="loGgS"></a>
# 概念
> MDN:
> A **closure** is the combination of a function bundled together (enclosed) with references to its surrounding state (the **lexical environment**). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.

函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起构成**闭包**。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。<br />


<a name="Ea6NW"></a>
# 特性
1.函数嵌套函数，父级函数 返回 子函数体 给全局。<br />2.子函数 访问 父级函数 的局部变量<br />3.变量不会被垃圾回收机制回收<br />
<br />目的：把局部变量 变成 自由变量（生命周期永久的和页面同存）<br />作用：函数内部的变量可以在外部被访问<br />
<br />⚠️ 函数嵌套函数+内部函数使用了外部函数的自由变量<br />⚠️ 函数嵌套了异步函数，该异步函数不算是内层函数。类似于setTimeout等异步函数中的回调函数，不算内层函数<br />
<br />

<a name="vCvmy"></a>
# 缺点
常驻内存，会增大内存的使用量，使用不当会造成内存泄漏。<br />
<br />闭包产生的变量不用了就赋值为null，垃圾回收机制就会释放掉。<br />

<a name="OGj1A"></a>
# 示例<br />
函数fatherFn 的子函数childFn，被函数fatherFn 外部的一个变量outerFn引用的时候，就创建了一个闭包。<br />在执行完 var outerFn = fatherFn() 后，变量outerFn实际上是指向了函数childFn，再执行outerFn() 后就会打印val的值(第一次为11)。这段代码其实就创建了一个闭包。因为 函数fatherFn 外的 变量outerFn 引用了 函数fatherFn 内的 函数childFn。
```javascript
function fatherFn(){
  var val = 10;
  return function childFn(){
    val += 1;
    console.log(val);
  }
}

var outerFn = fatherFn();
outerFn(); // 11
outerFn(); // 12
```

<br />

```javascript
// 正确的写法
function father(){
  var array = [];
  for (var i=0; i<10; i++) {
    (function(){
      var j= i; // 自由变量j
      array[i] =  function(){
        return  j;
      }
    })()
  }
  return array;
}

function father(){
  var array = [];
  for (var i=0; i<10; i++) {
    (function(j){
      // 自由变量j
      array[j] =  function(){
        return  j;
      }
    })(i)
  }
  return array;
}

// 错误的写法 没有使用父级函数的局部变量
function father(){
  var array = [];
  for (var i = 0; i < 10; i++) {
    // 祖先函数的作用域
    (function(){
      // 父级函数的作用域
      array[i] =  function(){
        return i;
      }
    })()
  }
  return array;
}
```


```javascript
// 闭包
for(var i=0;i<10;i++){
  (function wrap(i){
    setTimeout(function a(){
      console.log(i);
    },1000);
  })(i)
}
// 0到9
```

<br />

```javascript
// 非闭包
for(var i=0;i<10;i++){
  setTimeout(function a(){
    console.log(i);
  },1000)
}

// 10个10

// 非闭包
for(var i=0;i<10;i++){
  new Promise(resolve=>{
    resolve();
  }).then(()=>{
    console.log(i);
  })
}

// 10个10
```

<br />

```javascript
// 非闭包
var name = "The Window";
var object = {
  name : "My Object",
  getNameFunc : function(){
    return function(){
      return this.name;
    };
  }
};

console.log(object.getNameFunc()()); // The Window

// 闭包
var name = "The Window";
var object = {
  name : "My Object",
  getNameFunc : function(){
    // 使用 that 保存 this
    var that = this;
    return function(){
      // 使用父级函数的局部变量 that
      return that.name;
    };
  }
};

console.log(object.getNameFunc()()); // My Object
```


<a name="Ey01l"></a>
# 过时的闭包
过时的闭包捕获具有过时值的变量。
```jsx
function createIncrement(i) {
  var value = 0;

  return function increment() {
    value += i;
    console.log(value);
    // message中的value对于 logValue函数 来说，已经不是父级函数的局部变量了。
    var message = `Current value is ${value}`;

    return function logValue() {
      console.log(message);
    };
  }
}

var inc = createIncrement(1);
var log = inc(); // 打印 1
inc(); // 打印 2
inc(); // 打印 3
// ⽆法正确⼯作，打印出错误的数据
log(); // 打印 "Current value is 1"
```

<br />在第一次调用inc()时，返回的闭包被分配给变量 log。对 inc() 的 3 次调用的增量 value 为 3。<br />最后，调用log() 打印 message “Current value is 1”，这是出乎意料的，因为此时 value 等于 3。<br />
<br />log() 是过时的闭包。在第一次调用 inc() 时，闭包 log() 捕获了具有 “Current value is 1” 的 message 变量。而现在，当 value 已经是 3 时，message 变量已经过时了。<br />

<a name="item-4"></a>
## 修复过时闭包的问题
<a name="xdXg1"></a>
#### 使用新的闭包
找到捕获了最新 message 变量的闭包。就是从最后一次调用 inc() 返回的闭包。
```javascript
var inc = createIncrement(1);
inc();  // 打印 1
inc();  // 打印 2
var latestLog = inc(); // 打印 3
// 正常工作
latestLog(); // 打印 "Current value is 3"
```

<br />latestLog 捕获的 message 变量具有最新的的值 “Current value is 3”。<br />顺便说一下，这大概就是 React Hook 处理闭包新鲜度的方式。<br />Hooks 实现假设在组件重新渲染之间，作为 Hook 回调提供的最新闭包(例如 useEffect(callback)) 已经从组件的函数作用域捕获了最新的变量。<br />

<a name="avvBC"></a>
#### 关闭已更改的变量
第二种方法是让logValue()直接使用 value。<br />让我们移动行 const message = ...; 到 logValue() 函数体中：
```javascript
function createIncrementFixed(i) {
  var value = 0;
  function increment() {
    value += i;
    console.log(value);
    return function logValue() {
      var message = `Current value is ${value}`;
      console.log(message);
    };
  }
  
  return increment;
}
var inc = createIncrementFixed(1);
var log = inc(); // 打印 1
inc();             // 打印 2
inc();             // 打印 3
// 正常工作
log();             // 打印 "Current value is 3"
```

<br />logValue() 关闭 createIncrementFixed() 作用域内的 value 变量。<br />log() 现在打印正确的消息“Current value is 3”。<br />
<br />

<a name="FDi4D"></a>
# 相关知识点
<a name="sLBRk"></a>
#### 作用域
内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，但任何环境都不能向下搜索作用域链而进入另一个执行环境。<br />

<a name="v0ItD"></a>
#### 垃圾回收原理
(1)javascript中如果一个对象不再被引用，那么这个对象就会被回收。<br />(2)如果两个对象互相引用，而不再被第3者引用，那么这两个互相引用的对象也会被回收。<br />

<a name="1xPPq"></a>
#### 内存泄漏
产生原因：

- 意外的全局变量
- 被遗忘的定时器或者回调
- 没有清理的Dom元素引用
- 闭包
- IE7/8引用计数使用循环引用产生的问题


<br />解决办法：<br />1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；<br />2）注意程序逻辑，避免“死循环”之类的 ；<br />3）避免创建过多的对象  原则：不用了的东西要及时归还。<br />
<br />
<br />参考<br />[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)<br />[https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)<br />[https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016](https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016)<br />[https://www.runoob.com/js/js-function-closures.html](https://www.runoob.com/js/js-function-closures.html)<br />[https://blog.csdn.net/webxiaoma/article/details/53213113](https://blog.csdn.net/webxiaoma/article/details/53213113)<br />[https://segmentfault.com/a/1190000020805789?utm_source=tag-newest](https://segmentfault.com/a/1190000020805789?utm_source=tag-newest)<br />

